<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        // 3.4.4
        // let message = "hi";
        // console.log(Boolean(message));  // true

        // console.log(Boolean())  
        
        // let num1 = 0X100;
        // console.log(num1)
        // let num = Number.MAX_VALUE * 2;
        // console.log(isFinite(num));
        // function add(a, b){
        //     return a+b;
        // }

        // let num1 = 10;
        // let num2 = 100;

        // let str = `${num1} + ${num2} = ${add(num1, num2)}`;
        // console.log(str);
        // let obj = {
        //     toString: ()=>"this is toString"
        // }
        // console.log(`${obj}`);
        // console.log(`${null}`); // "null"

        // 模板字面量标签函数

        // let a = 1;
        // let b = 2;
        // function simpleTag(strings, aValue, bValue, sumValue){
        //     console.log(strings);
        //     console.log(aValue);
        //     console.log(bValue);
        //     console.log(sumValue);

        //     return 'simpleTag function runs over';
        // }
        // let returnValue = simpleTag`${a} + ${b} = ${a+b}`;
        // // '', ' + ', ' = ', ''
        // // 1
        // // 2
        // // 3

        // console.log(returnValue);
        // // simpleTag function runs over


        // let a = 2; 
        // let b = 3;
        // function simpleTag(strings, ...expressions){
        //     console.log(strings);

        //     for(const expression of expressions){
        //         console.log(expression);
        //     }
        //     return 'simpleTag function runs over successfully'
        // }

        // let returnValue = simpleTag`${a} + ${b} = ${a+b}`;
        // // '', ' + ', ' = ', ''
        // // 2
        // // 3
        // // 5
        // console.log(returnValue);
        // // simpleTag function runs over successfully


        // let a = 10;
        // let b = 100;
        // function TagFunc(strings, ...expressions){
        //     return strings[0] + expressions.map((e,i)=>`${e}${strings[i+1]}`).join(' ')
        // }

        // let returnValue = TagFunc`${a} + ${b} = ${a+b}`;
        // console.log(returnValue);
        // // 10 +  100 =  110

        // 原始字符串
        
        // 标签函数
        // console.log(`\u00A9`);  // ©
        // console.log(String.raw`\u00A9`);    // \u00A9

//         console.log(String.raw`hello \n world`);    // hello \n world
//         // 对实际的换行符没用, 因为实际的换行符不会被转换为转义序列的形式
//         console.log(String.raw`hello
// world`);

        // 标签函数的第一个参数(字符串数组), 其有一个.raw数学, 可以获得每个字符串的原始内容
        // function TagFunc(strings) {
        //     console.log('显示原始字符串:');
        //     for(const str of strings.raw){
        //         console.log(str);
        //     }
        // }

        // TagFunc`\u00A9${'hi'}\n`
        // // 显示原始字符串:
        // // test.html:104 \u00A9
        // // test.html:104 \n

        // let mySym1 = Symbol();
        // let mySym2 = Symbol();
        // let hisSym1 = Symbol('His');
        // let hisSym2 = Symbol('His');

        // console.log(mySym1 == mySym2);      // false
        // console.log(hisSym1 == hisSym2);    // false    

        // let mySym1 = Symbol();
        // let mySym2 = Symbol();
        // console.log(mySym1 == mySym2);      // false
        // console.log(mySym1 === mySym2);     // false   
        
        // let myBoolean = new Boolean();
        // console.log(myBoolean);     // Boolean {false}

        // let myString = new String();
        // console.log(myString);      // String {''}

        // let mySymbol = new Symbol();
        // console.log(mySymbol);      // TypeError: Symbol is not a constructor

        // let mySymbol = Symbol();
        // let myObjectSymbol = Object(mySymbol);
        // console.log(typeof myObjectSymbol);     // object

        // let globalSymbol = Symbol.for('thisIsGlobalSymbol');
        // console.log(typeof globalSymbol);   // symbol

        // console.log(Symbol.keyFor(globalSymbol));   // thisIsGlobalSymbol

        // let normalSymbol = Symbol('this is normal symbol');
        // console.log(Symbol.keyFor(normalSymbol));   // undefined
        // console.log(Symbol.keyFor(normalSymbol) === undefined );   // true
        // console.log(Symbol.keyFor(normalSymbol) === 'undefined' );   // false

        // let normalUndefinedSymbol = Symbol.for('undefined');
        // console.log(Symbol.keyFor(normalUndefinedSymbol));      // undefined
        // console.log(Symbol.keyFor(normalUndefinedSymbol) === undefined);      // false
        // console.log(Symbol.keyFor(normalUndefinedSymbol) === 'undefined');      // true


// let globalSymbol = Symbol.for('something');
// let normalSymbol1 = Symbol('something');
// let normalSymbol2 = Symbol('something');

// console.log(globalSymbol === normalSymbol1);    // false
// console.log(normalSymbol1 === normalSymbol2);   // false  

// Symbol.keyFor(1);       // TypeError: 1 is not a symbol

// let mySymbol1 = Symbol('one');
// let myObj = {
//     [mySymbol1]: 'hello'
// }

// console.log(myObj);     // {Symbol(one): 'hello'}

// let mySymbol2 = Symbol('two');
// myObj[mySymbol2] = 'world';

// console.log(myObj);     // {Symbol(one): 'hello', Symbol(two): 'world'}

// let myObj = {};
// let mySymbol1 = Symbol('defineProperty');
// let mySymbol2 = Symbol('defineProperties 1');
// let mySymbol3 = Symbol('defineProperties 2');


// Object.defineProperty(myObj, mySymbol1, {value: 'defineProperty value'});
// console.log(myObj);
// // {Symbol(defineProperty): 'defineProperty value'}

// Object.defineProperties(myObj, {
//     [mySymbol2]: {value: 'mySymbol2 defineProperties1 value'},
//     [mySymbol3]: {value: 'mySymbol3 defineProperties2 value'}
// })
// console.log(myObj);
// // {
// // Symbol(defineProperty): 'defineProperty value', 
// // Symbol(defineProperties 1): 'mySymbol2 defineProperties1 value', 
// // Symbol(defineProperties 2): 'mySymbol3 defineProperties2 value'
// }

// let s1 = Symbol('s1');
// let s2 = Symbol('s2');

// let obj = {
//     [s1]: 'this is s1',
//     [s2]: 'this is s2',
//     name: 'zhangsan',
//     age: 18
// }

// console.log(Object.getOwnPropertyNames(obj));
// // (2) ['name', 'age']

// console.log(Object.getOwnPropertySymbols(obj));
// // (2) [Symbol(s1), Symbol(s2)]

// console.log(Object.getOwnPropertyDescriptors(obj));
// // {name: {…}, age: {…}, Symbol(s1): {…}, Symbol(s2): {…}}

// console.log(Reflect.ownKeys(obj));
// // (4) ['name', 'age', Symbol(s1), Symbol(s2)]

// let myObj = new Object();

// // ECMAScript只要求在给构造函数提供参数时使用括号
// // 所以不提供参数时不使用括号也是没有问题的， 但不推荐
// let otherObj = new Object;

// console.log(myObj);     // {}
// console.log(otherObj);  // {}


// let myObj = new Object();
// myObj.name = 'zhangsan';
// console.log(myObj.hasOwnProperty('name'));

// let myObj = new Object();
// myObj.arr = [1,2,3,4];
// console.log(myObj.propertyIsEnumerable('arr'));     // true

// let age = 17;
// console.log(age++);     // 17
// console.log(age);       // 18

/*
let s1 = '1';
let s2 = 'something';

let b1 = false;
let b2 = true;

let f1 = 1.1;

let o1 = {
    valueOf() {
        return 1;
    }
};


console.log(++s1);      // 2 
console.log(++s2);      // NaN
console.log(++b1);      // 1
console.log(++b2);      // 2 
console.log(--f1);      // 0.10000000000000009  二进制表示浮点数不精准
console.log(++o1);      // 2
*/

// let a = {
//     age: 9

// }

// let b = {
//     age: 9
// }

// console.log(a===b);


// let o = {
//     name: 'zhangsan',
//     age: 17
// }

// for(const k in o) {
//     console.log(k);
// }

// let arr = [2,3,4,5];
// for(const i of arr) {
//     console.log(i);
// }


// let a = new Number(2);
// console.log(a instanceof Number)

/*
console.log( [0,0,1,0,0].join('') )             // 00100
console.log( typeof [0,0,1,0,0].join('') )      // string

console.log( [0,0,1,0,0].join('') + 1 )             // 001001
console.log( typeof ([0,0,1,0,0].join('') + 1) )    // string
 
console.log( parseInt( [0,0,1,0,0].join('') + 1 ) )         // 1001
console.log( typeof parseInt([0,0,1,0,0].join('') + 1) )    // number


*/

/*
let F = function() {
    // 这相当于是F的构造函数

    // 只是在构造函数中写上了let num = 1；实际是只是对象的构造函数中的一个局部变量， 构造函数执行完就被销毁了， num1并没有什么用处
    let num1 = 1;

    // 构造函数中使用this指向的是调用该构造函数的对象， 也就是下面的f，f.num2 = 2, 则在对象f创建了一个变量num2
    this.num2 = 2;
}
let f = new F();

console.log(f);
*/


function F(age){
    return new Number(30);
}

console.log(new F(3));















    </script>



</body>
</html>