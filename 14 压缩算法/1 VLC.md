# VLC
variable-length code

计算每个元素出现的概率, 并用不同长度的0/1比特进行表示, 且概率最高的元素使用的长度最短

由于出现概率大, 如果对其的编码越短, 则得到的最终比特流越短

例如
```
A 出现概率: 0.49    使用编码 0
B 出现概率: 0.25    使用编码 10
C 出现概率: 0.25    使用编码 110
D 出现概率: 0.01    使用编码 111

如:ABAAACBD编码后为:
    01000011010111
使用了14个bit

如果正常编码, 一共ABCD, 则需要log2(4)=2的长度的0/1序列
若: 
    A: 00
    B: 01
    C: 10
    D: 11
则上面的字符串ABAAACBD需要 8*2 = 16 个比特
```

以上VLC指的是一系列的算法, 特征为 variable-length, 而不仅仅是上述所讲的算法

而上述所讲的算法可以由 **哈夫曼编码** 进行构造以避免出现 **前缀**

```
上述所讲的算法最开始在摩斯密码中使用, 目的是发送电报
简而言之长电流信号代表1, 短代表0(相反亦可)

26个英文字母加上逗号 句号 结束标记 等, 
为了使发报员安得次数最少, 统计了这些字符在英文中出现的概率, 概率最高的字符使用最短的播报方式
具体可以百度查查, 这里原理类似, 不多介绍

```

# 前缀性质

例如前面的ABCD四种字符分别使用如下四种比特流进行标记
```
    A 0
    B 10
    C 101
    D 110
```
那么解码时, 出现类似 101010 的比特流, 无法确定是 CAB 或是 BBB...

即这种编码出来的比特流可能会出现歧义

而哈夫曼编码使用哈夫曼树可以避免这种情况, 不了解哈夫曼树的可以自己百度看看

# 二进制编码

习惯使用B(n)来表示整数n的二进制表示, 这通常被称为beta编码或 **二进制编码**

但是他不满足前缀性质, 除非使用固定长度:

对于0~n的整数, 我们可以使用[lb(n)]个bit位来表示任意一个属于0~n的整数

# 一元码

对于整数n, 一元码为 n-1 个 1 后跟着 1个0

例如
3: 1110
4: 11110

由于每两个元素直接被0分开, 其满足前缀性质

由于每多一个元素就多一位, 则其用在 **元素pi出现的概率 >= 2 * 元素pi+1出现的概率** 这种情况比较好
例如
```
A: 66%      编码: 0
B: 33%      编码: 10
C:  1%      编码: 110
```

# Elias Gamma 编码

此编码用于 无法确定0~n中的n到底有多大 时
即无法确定最大数的上界时

1. 令 N = floor(log2(x))

    ```
    floor表示向下取整
    ```
2. 令 L = x - 2^N

3. 用一元码表示N

4. 将L表示为长位N的二进制编码

5. 将步骤4得到的结果加在步骤3得到的结果之后

例如: 
```
对于整数 12

1.  N = floor(log2(12)) = 3

2.  L = 12 - 2^N = 12 - 2^3 = 4

3.  N使用一元码表示: 110

4.  L使用N位的二进制表示, 即 将4表示为3位的二进制数: 100

5.  将4得到的结果拼接于3得到的结果之后: 110100
```

很明显这种编码可以对不同的n达到即时编码的效果, 且解码时有唯一性

# Elias Delta 编码

对于要编码的数x

1. 用二进制表示x
2. 令x的二进制表示结果的长度为 L, 设C为L的二进制形式
3. x的最左一位必然是1, 去掉, 得到E
4. 将E加到C末尾得到M
5. 在M前面添加C的长度-1个0

解码看着怎么编码然后对应着解就行了

相比于Elias Gamma编码, 这个也太操了...


# Varint 算法
## VLC的问题
VLC算法的问题:
1. 不按字节/字/整型对齐, 不同编码方式可能不同的数的编码的长度不同, 且很难完全按一个字节长度来实现
2. 对于较大的数n, 为了方便解码, 其码字长度的增长速度一般会超过lb(n)个bit位

    ```
    对于任意一个n, [lb(n)] 位bit即可表示, 但是为了方便编码, 通常会超过这个值
    例如最开始的ABCD只有四种字符的时候, 如果固定长度则只需要两个bit位:
        A: 00
        B: 01
        C: 10
        D: 11

    但是我们的编码:
        A 出现概率: 0.49    使用编码 0
        B 出现概率: 0.25    使用编码 10
        C 出现概率: 0.25    使用编码 110
        D 出现概率: 0.01    使用编码 111
    C与D却用了3位
    
    对于其他的数也是类似, 如上面的 Elias Gamma 和 Elias Delta
    虽然他们无视上界, 但是使用的bit位远超过 [lb(n)]

    ```

3. 解码速度慢, 每经过一个bit位就要分析一次, 例如一元码, 每经过一个bit位都要分析一下这一位是不是0


因此VLC一般用于表示压缩数据流, 没啥其他应用
```
<<数据压缩入门>>一书: 因而只能用于表示压缩数据量, 没有其他应用
```


对于一些需要处理很多大整数的系统来说, 这些问题使得VLC无法应用

## Varint算法

用于表示整数的方法
用一个或多个字节表示一个整数, 整数越小则字节数越少, 反之则反

将每个字节的最高有效位(MSB, most significant bit)作为布尔标志
```
为1则表示该整数还有后续字节, 为0则表示该字节是最后一个字节
```

Varint表示时, 低位字节在前, 高位字节在后

例如
```
300的二进制为:100101100, 
一共9位, 超过了7位, 低于 2*7=14 位, 故只需要两个字节来表示

2*8 - 9 - 1*2 = 5,

其中9为300的二进制有多少位bit, 
1*2表示用两个字节保存时会消耗两个MSB位, 
则需要补充5个0, 以凑齐两个字节=16位的长度

补充后为 0000010 0101100, 
地位在前高位在后, 于是表示为: 0101100 0000010

添加MSB标志:
从左到右第一个字节这个数没有结束, MSB为1, 即为: 10101100
第二个字节, 当前字节为该数最后一个字节, 故MSB为0, 即为: 00000010

故从左到右两个字节, 300被表示为: 10101100 00000010
```


# 终
VLC中不同的编码方式在给定符号的概率分布不同时, 表现也会有很大差别

如何选择一个合适的编码方式至关重要, 否则可能得到一个更大的数据流

在信息论发展的最初15年左右的时间里, 数据压缩技术完全局限于VLC方法
总的来说, 压缩数据时工程师要做的就是选一个合适的编码方式

庆幸的是这种情况已经一去不复返了